<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Prioritizing Reliability When Milliseconds Aren&#39;t Enough | ByteAether</title><meta name="description" content="Decoding complexity to craft beautiful simplicity."><meta name="keywords" content="posts, ULID, UUID, GUID, ID, Performance, c#, csharp, dotnet, .net, byteaether, blog, tech, programming"><meta name="author" content="Joonatan Uusväli"><link rel="canonical" href="https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/"><script type="application/ld+json">{
	"@context": "https://schema.org",
	"@type": "BlogPosting",
	"mainEntityOfPage": {
		"@type": "WebPage",
		"@id": "https://byteaether.github.io/"
	},
	"headline": "Prioritizing Reliability When Milliseconds Aren&#39;t Enough",
	"description": "Decoding complexity to craft beautiful simplicity.",
	"image": "https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/8Ivkx3_DqV-1024.webp",
	"author": {
		"@type": "Person",
		"name": "Joonatan Uusväli"
	},
	"publisher": {
		"@type": "Organization",
		"name": "ByteAether",
		"logo": {
			"@type": "ImageObject",
			"url": "https://byteaether.github.io/assets/icon.svg"
		}
	},
	"datePublished": "2025-06-19",
	"dateModified": "2025-08-14"
}</script><link rel="icon" href="/favicon.ico" sizes="any"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="manifest" href="/manifest.webmanifest"><meta property="og:url" content="https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/"><meta property="og:type" content="website"><meta property="og:title" content="Prioritizing Reliability When Milliseconds Aren&#39;t Enough | ByteAether"><meta property="og:description" content="Decoding complexity to craft beautiful simplicity."><meta property="og:image" content="https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/8Ivkx3_DqV-1024.webp"><meta property="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Prioritizing Reliability When Milliseconds Aren&#39;t Enough | ByteAether"><meta name="twitter:description" content="Decoding complexity to craft beautiful simplicity."><meta name="twitter:image" content="https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/8Ivkx3_DqV-1024.webp"><meta name="robots" content="index, follow"><link rel="alternate" href="https://byteaether.github.io/feed/feed.xml" type="application/atom+xml" title="ByteAether"><meta name="format-detection" content="telephone=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta http-equiv="cache-control" content="public, max-age=86400, must-revalidate"><meta name="generator" content="Eleventy v3.1.2"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-LEY00265EM"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-LEY00265EM")</script><link rel="stylesheet" href="/css/pjMU8f3nxQ.css"><link rel="stylesheet" href="/css/tka8cbboE1.css"><script type="text/javascript">const themeManager={init:function(){this.set(this.get())},toggle:function(){this.set("dark"==this.get()?"light":"dark")},set:function(e){document.documentElement.dataset.theme=e,localStorage.theme=e,this.updateGiscusTheme()},get:function(){return document.documentElement.dataset.theme??localStorage.theme??(window.matchMedia&&window.matchMedia("prefers-color-scheme: dark")?"dark":null)??"light"},updateGiscusTheme:function(){const e="dark"===themeManager.get()?"dark":"light",t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}};themeManager.init()</script></head><body><a href="#skip" class="visually-hidden">Skip to main content</a><header><div id="header-container"><a href="/" class="header-left"><img src="/assets/icon.svg" alt="Logo" class="logo-img"> ByteAether</a><nav class="desktop-nav"><ul><li><a href="/">Home</a></li><li><a href="/search/">Search</a></li><li><a href="/series/">Series</a></li><li><a href="/tags/">Tags</a></li><li><a href="/archive/">Archive</a></li><li><a href="/about/">About</a></li></ul></nav><div class="header-right"><a href="https://github.com/ByteAether" title="ByteAether" target="_blank"><svg class="icon" aria-hidden="true"><use href="#fab-fa-github" xlink:href="#fab-fa-github"></use></svg></a><a href="/feed/feed.xml" title="Feed" target="_blank"><svg class="icon" aria-hidden="true"><use href="#fas-fa-square-rss" xlink:href="#fas-fa-square-rss"></use></svg></a><span onclick="themeManager.toggle()"><svg class="icon" aria-hidden="true"><use href="#fas-fa-sun" xlink:href="#fas-fa-sun"></use></svg></span><label for="nav-toggle" class="burger-menu"><svg class="icon" aria-hidden="true"><use href="#fas-fa-bars" xlink:href="#fas-fa-bars"></use></svg></label></div><input type="checkbox" id="nav-toggle" class="nav-toggle"><nav class="mobile-nav"><ul><li><a href="/">Home</a></li><li><a href="/search/">Search</a></li><li><a href="/series/">Series</a></li><li><a href="/tags/">Tags</a></li><li><a href="/archive/">Archive</a></li><li><a href="/about/">About</a></li></ul></nav></div></header><div class="content-wrapper"><main id="skip"><heading-anchors><article><img src="/2025/prioritizing-reliability-when-milliseconds-arent-enough/8Ivkx3_DqV-1024.webp" alt="Illustration image for an article" class="banner"><h1 class="post-title" data-pagefind-meta="title, image:/2025/prioritizing-reliability-when-milliseconds-arent-enough/8Ivkx3_DqV-400.webp" data-pagefind-sort="date:2025-06-19">Prioritizing Reliability When Milliseconds Aren&#39;t Enough</h1><div class="post-meta"><div class="post-metadata"><div><svg class="icon" aria-hidden="true"><use href="#far-fa-calendar" xlink:href="#far-fa-calendar"></use></svg> <time datetime="2025-06-19" data-pagefind-meta="Published" title="Published at 2025-06-19, updated at 2025-08-14">2025-06-19</time> <span style="display:none" data-pagefind-filter="Year">2025</span></div><div data-words="2,261 words"><svg class="icon" aria-hidden="true"><use href="#far-fa-clock" xlink:href="#far-fa-clock"></use></svg> 11 minutes</div><div><svg class="icon" aria-hidden="true"><use href="#fas-fa-rectangle-list" xlink:href="#fas-fa-rectangle-list"></use></svg> <span class="serie" data-pagefind-filter="Series"><a href="/series/byteaether-ulid/">ByteAether.Ulid</a></span></div><div><svg class="icon" aria-hidden="true"><use href="#fas-fa-tags" xlink:href="#fas-fa-tags"></use></svg> <span class="tag" data-pagefind-filter="Tags"><a href="/tags/ulid/">ULID</a></span> <span class="tag" data-pagefind-filter="Tags"><a href="/tags/uuid/">UUID</a></span> <span class="tag" data-pagefind-filter="Tags"><a href="/tags/guid/">GUID</a></span> <span class="tag" data-pagefind-filter="Tags"><a href="/tags/id/">ID</a></span> <span class="tag" data-pagefind-filter="Tags"><a href="/tags/performance/">Performance</a></span></div></div></div><div data-pagefind-body=""><p>Universally Unique Lexicographically Sortable Identifiers (ULIDs) represent a significant advancement over traditional UUIDs, offering guaranteed uniqueness (within practical limits), natural sortability by time, and a concise, URL-friendly format. These features make them highly suitable for diverse applications, including database keys, distributed tracing, and event identifiers. While the intricacies of ID generation might seem like a deep concern primarily for high-throughput systems, understanding the underlying design choices is valuable for all developers leveraging such libraries.</p><p>A standard ULID consists of a 48-bit timestamp (milliseconds since the Unix epoch) and an 80-bit random component. This structure ensures IDs generally sort chronologically. However, the official specification includes a mechanism to handle multiple IDs generated within the <em>exact same millisecond</em>: it increments the 80-bit random part sequentially. This leads to a critical question: What happens if this increment causes the 80-bit random part to exceed its maximum value?</p><p><a href="https://github.com/ulid/spec" target="_blank" rel="noopener noreferrer">The official specification</a> mandates throwing an overflow exception in this situation. While this adheres strictly to the definition, it introduces a potential point of failure, especially in high-performance systems. Crucially, this isn't just a theoretical concern that requires generating 2^80 IDs. For the <em>first</em> ULID generated within a specific millisecond, the 80-bit portion is initialized with a cryptographically random value. If this initial random value happens to be very close to the maximum possible value (all 1's in binary), even the <em>second</em> ID generated within that same millisecond could trigger the increment overflow and, consequently, an exception. This makes the overflow a far more probable scenario than one might initially assume based purely on the size of the 80-bit space.</p><p>In developing <strong><a href="/series/byteaether-ulid/">ByteAether.Ulid</a></strong>, our C# implementation available on <a href="https://github.com/ByteAether/Ulid" target="_blank" rel="noopener noreferrer">GitHub</a> and <a href="https://www.nuget.org/packages/ByteAether.Ulid" target="_blank" rel="noopener noreferrer">NuGet</a>, we recognized the practical implications of this potential exception. We made a deliberate design choice, a documented deviation from the strict specification, to enhance dependability: instead of throwing an exception, <strong>ByteAether.Ulid</strong> allows the increment operation to <em>flow into the 48-bit timestamp part</em> when the 80-bit random part overflows. This post explains the rationale behind this decision.</p><h2 id="the-overflow-scenario%3A-more-likely-than-you-think" tabindex="-1">The Overflow Scenario: More Likely Than You Think</h2><p>Consider systems that demand high throughput: real-time analytics pipelines, busy web servers handling rapid requests, IoT data ingestion points, or batch processing jobs churning through records. In these environments, generating multiple unique identifiers within a single millisecond is commonplace.</p><p>The ULID specification's approach ensures monotonicity <em>within</em> a millisecond by incrementing the random part. For example:</p><ol><li><code>Ulid.New()</code> at <code>T</code> ms: <code>[Timestamp T | Random Value R1]</code></li><li><code>Ulid.New()</code> at <code>T</code> ms again: <code>[Timestamp T | Random Value R1 + 1]</code></li><li><code>Ulid.New()</code> at <code>T</code> ms yet again: <code>[Timestamp T | Random Value R1 + 2]</code> ... and so on.</li></ol><p>The issue arises when <code>Random Value R1 + n</code> reaches the maximum value representable by 80 bits. As noted earlier, if the initial <code>Random Value R1</code> generated by the secure random number generator is already near this maximum, it might only take one or two subsequent calls to <code>Ulid.New()</code> within the same millisecond to hit the ceiling, if the initial random draw was exceptionally unlucky (i.e., very close to the maximum).</p><p>An implementation strictly following the spec would then throw an exception. This creates significant challenges:</p><ol><li><strong>Reduced Reliability:</strong> ID generation, a typically background concern, becomes a potential source of runtime failure, especially under peak load conditions where reliability is most critical.</li><li><strong>Increased Complexity &amp; Performance Impact:</strong> Developers must anticipate and handle these exceptions. <code>try-catch</code> blocks, particularly when an exception is actually thrown, can incur a non-trivial performance cost, especially in very hot code paths like ID generation. This might lead to implementing retry logic or other workarounds that add complexity and can negatively impact the very performance ULIDs are often chosen to support.</li></ol><h3 id="update%3A-the-impact-of-random-increments-on-overflow-probability" tabindex="-1">Update: The Impact of Random Increments on Overflow Probability</h3><p>With the release of <strong><a href="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/">ByteAether.Ulid v1.3.0</a></strong>, our decision to handle random-part overflow by incrementing the timestamp has become even more critical and relevant. The previous monotonic generation behavior, which incremented the random part by a fixed value of 1, made the overflow scenario more likely than one might assume, especially if the initial random value was close to the maximum.</p><p>The new <strong><code>GenerationOptions</code></strong> configuration object introduces several <code>MonotonicRandomXByte</code> options, which enhance security by allowing the increment value to be a random number. This value can range from 1 to 256 for <code>MonotonicRandom1Byte</code>, up to 1 to 4 294 967 296 for <code>MonotonicRandom4Byte</code>. While this adds an important layer of security against enumeration attacks, it also significantly increases the probability of an 80-bit random part overflow occurring within a single millisecond.</p><p>Consider a scenario where <code>MonotonicRandom4Byte</code> is used. A cryptographically secure random provider could generate an initial 80-bit random component close to the maximum value, and the very next ULID generated in that same millisecond could have an increment value of 2^32, causing an immediate overflow.</p><p>Our approach of allowing the increment to flow into the timestamp directly addresses this increased risk. Instead of a predictable, linear march toward a potential exception, the new random increments make the overflow threshold far more volatile. By not throwing an exception and instead seamlessly incrementing the timestamp, our implementation ensures continued, reliable operation under these new, more complex generation scenarios, reinforcing its value for robust and high-throughput systems.</p><h2 id="considering-the-alternatives" tabindex="-1">Considering the Alternatives</h2><p>When faced with the random-part overflow, beyond throwing an exception (as per the spec), several strategies exist:</p><ol><li><p><strong>Delay Generation:</strong> This approach involves pausing the generation thread until the system clock advances to the next millisecond. While ensuring the timestamp strictly reflects the wall-clock time (or a later one), it introduces artificial latency. Halting execution, even briefly, can create significant bottlenecks in high-throughput systems, effectively throttling the application's performance based on clock resolution rather than processing capability. This often defeats the purpose of using efficient ID generation.</p></li><li><p><strong>Force Initial MSB to Zero:</strong> This technique modifies the generation of the <em>initial</em> random value (<code>R1</code> in the example above) within a millisecond. The most significant bit (MSB) of the 80-bit random part is always set to 0. This effectively means the initial random value is always less than 2^79. Consequently, at least 2^79 increments are guaranteed to be possible within that millisecond before the 80-bit value overflows.</p><ul><li><strong>Pros:</strong> Drastically reduces the <em>probability</em> of encountering an overflow, as 2^79 increments within a single millisecond is practically impossible on current hardware. It eliminates the &quot;bad luck&quot; scenario where the first random value is already near the maximum.</li><li><strong>Cons:</strong> It doesn't technically <em>eliminate</em> the overflow problem, it just pushes the threshold extremely high. A decision is <em>still</em> required for what to do if that 2^79 limit is somehow reached (throw, delay, or increment timestamp). It also slightly reduces the initial entropy from 80 bits to 79 bits, though this effect on collision probability is generally negligible. Fundamentally, it mitigates the likelihood but not the existence of the overflow condition itself.</li></ul></li><li><p><strong>Allow Overflow into Timestamp:</strong> This is the strategy implemented in <strong>ByteAether.Ulid</strong>. When the 80-bit random part reaches its limit and needs to increment, the increment operation carries over, increasing the 48-bit timestamp component by one millisecond. The practical effect is that the generated ULID might have a timestamp slightly &quot;ahead&quot; of the precise system clock time at the moment of generation.</p></li></ol><p>Comparing these, the <strong>ByteAether.Ulid</strong> approach directly addresses the <em>consequence</em> of the overflow by providing a non-blocking, non-exception-throwing resolution, regardless of how likely the overflow is. We contend that this provides the optimal blend of performance, reliability, and practical sortability for demanding applications.</p><h2 id="understanding-the-impact%3A-monotonicity-in-practice" tabindex="-1">Understanding the Impact: Monotonicity in Practice</h2><p>A natural question regarding the timestamp overflow approach is its effect on ULID's sortability and monotonicity guarantees. It's essential to analyze this within realistic contexts.</p><p><strong>Single-Process Monotonicity is Strictly Preserved:</strong> This is the cornerstone of the argument. Within a single running process, <strong>ByteAether.Ulid</strong> <em>guarantees</em> that each call to <code>Ulid.New()</code> produces a ULID value strictly greater than the previous one. Whether the increment occurs within the 80-bit random part or spills over into the 48-bit timestamp part, the resulting 128-bit value increases. This ensures that IDs generated sequentially <em>by the same generator instance</em> remain perfectly sortable relative to each other. This is often the most critical monotonicity requirement for use cases like database record ordering within an import batch.</p><p><strong>Cross-Process Monotonicity is Inherently Approximate:</strong> Attempting to achieve strict, guaranteed millisecond-level chronological ordering using ULIDs <em>across different machines or even different processes on the same machine</em> is inherently unreliable, irrespective of how overflow is handled. Factors like clock skew, network latency, and scheduling jitter mean you cannot reliably assert that <code>ULID_A</code> generated on <code>Machine_1</code> at its perceived time <code>T</code> is strictly less than <code>ULID_B</code> generated on <code>Machine_2</code> at its perceived time <code>T + 1ms</code>.</p><p>Given this reality, the fact that <strong>ByteAether.Ulid</strong> might, in high-contention scenarios, advance the timestamp by a millisecond due to overflow does not practically diminish the utility of ULIDs for cross-process chronological estimation. The timestamp remains a highly accurate representation of the generation time. Crucially, this &quot;future-drift&quot; is typically only by a single millisecond; once the timestamp increments, the subsequent ULID generated in this &quot;new&quot; millisecond has the full 2^80 range for its random component, making further immediate overflows into the timestamp exceptionally unlikely. This minimal adjustment is well within the margin of error already introduced by system clocks and network effects, and it prevents generation failure without meaningfully impacting the approximate sortability expected in distributed contexts.</p><p><strong>Alternative - Centralized ID Generation:</strong> One could achieve stronger cross-instance monotonicity by funneling all ID requests through a dedicated, single-instance &quot;ID Generator Service.&quot; This service could maintain strict ordering. However, this introduces significant drawbacks: primarily, <strong>network latency</strong> for every ID request and a <strong>single point of failure/bottleneck</strong>. This contrasts sharply with the benefit of ULIDs: fast, decentralized, in-process generation. For systems prioritizing low-latency generation, the centralized approach is often impractical.</p><p>In summary, <strong>ByteAether.Ulid</strong>'s approach trades theoretical timestamp purity (which is already compromised in distributed systems) for practical reliability and performance, while fully preserving the critical single-process monotonicity guarantee.</p><h2 id="why-reliable-monotonicity-matters%3A-the-data-import-example" tabindex="-1">Why Reliable Monotonicity Matters: The Data Import Example</h2><p>Let's revisit the large-scale data import workflow to illustrate the value of <strong>ByteAether.Ulid</strong>'s reliable single-process monotonicity. A single process reads millions of source records, transforms them, assigns a ULID, and inserts them into a database.</p><pre class="language-csharp"><code class="language-csharp"><span class="token comment">// Simplified Example using ByteAether.Ulid</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataImporter</span>
<span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IDatabaseRepository</span> _repository<span class="token punctuation">;</span>
	<span class="token comment">// ... constructor ...</span>

	<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ImportData</span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>SourceRecord<span class="token punctuation">></span></span> sourceRecords<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token class-name"><span class="token keyword">var</span></span> recordsToInsert <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>TargetRecord<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> sourceRecord <span class="token keyword">in</span> sourceRecords<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token comment">// ByteAether.Ulid handles potential same-ms overflow gracefully</span>
			<span class="token comment">// Potential high-frequency generation here!</span>
			<span class="token class-name">Ulid</span> newId <span class="token operator">=</span> Ulid<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token class-name"><span class="token keyword">var</span></span> targetRecord <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TargetRecord</span> <span class="token punctuation">{</span>
				Id <span class="token operator">=</span> newId<span class="token punctuation">,</span>
				<span class="token comment">/* ... other fields ... */</span>
			<span class="token punctuation">}</span><span class="token punctuation">;</span>
			recordsToInsert<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>targetRecord<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		_repository<span class="token punctuation">.</span><span class="token function">BulkInsert</span><span class="token punctuation">(</span>recordsToInsert<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// ... other methods and record definitions ...</span>
<span class="token punctuation">}</span></code></pre><p><strong>Advantages in this Scenario:</strong></p><ol><li><strong>Dependable High-Speed Operation:</strong> The import can run at full speed. Even if bursts occur where the random part of the ULID would overflow (potentially after just one previous generation in the same millisecond if the initial random value was high), <strong>ByteAether.Ulid</strong> seamlessly increments the timestamp and continues generation without throwing exceptions. This prevents job failures and avoids the need for complex error handling around <code>Ulid.New()</code>.</li><li><strong>Preserved Processing Order:</strong> Because each <code>newId</code> is guaranteed to be greater than the last within this import process, the generated IDs maintain the sequence in which records were handled. If used as a clustered primary key, this aids database insertion performance and allows efficient time-based range queries on the imported batch. The sequence is inherent in the IDs themselves.</li><li><strong>No Artificial Bottlenecks:</strong> Unlike a delay-based approach, <strong>ByteAether.Ulid</strong> doesn't artificially throttle the import speed based on millisecond clock ticks, allowing the system to utilize its full processing power.</li></ol><p>Using an implementation that throws exceptions could lead to sporadic, hard-to-reproduce failures during large imports. Using one that delays would unnecessarily extend the import duration. Using the MSB=0 approach would make failures <em>extremely</em> unlikely, but still theoretically possible, requiring a fallback strategy (like throwing or delaying anyway) that doesn't offer the same definitive resolution. <strong>ByteAether.Ulid</strong> provides a direct, reliable handling mechanism.</p><h2 id="a-pragmatic-choice-for-robust-systems" tabindex="-1">A Pragmatic Choice for Robust Systems</h2><p>The decision in <strong>ByteAether.Ulid</strong> to handle random-part overflow by incrementing the timestamp is a pragmatic one, driven by the need for reliability and performance in real-world applications. It recognizes that the overflow scenario is more likely than a simple 2^80 calculation suggests due to the random starting point within each millisecond.</p><p>This approach:</p><ul><li>Ensures <strong>dependability</strong> by eliminating a source of exceptions in high-throughput scenarios.</li><li>Maintains <strong>performance</strong> by avoiding the latency introduced by delay-based strategies and the overhead of frequent exception handling.</li><li>Guarantees <strong>strict single-process monotonicity</strong>, preserving the most reliable and often most crucial sortability aspect of ULIDs.</li><li>Acknowledges that <strong>cross-process millisecond ordering</strong> is already approximate, making the minor, typically single-millisecond timestamp adjustment during overflow insignificant in that context.</li><li>Provides a <strong>definitive handling mechanism</strong>, unlike approaches that merely reduce the <em>likelihood</em> of overflow without specifying the ultimate fallback.</li></ul><p>While representing a documented deviation from the specification's exception-throwing behavior, this design choice prioritizes building robust, performant systems that can handle demanding workloads without faltering. We believe this makes <strong><a href="https://github.com/ByteAether/Ulid" target="_blank" rel="noopener noreferrer">ByteAether.Ulid</a></strong> a strong choice for developers needing fast, reliable, and sortable unique identifiers in C#.</p></div></article><div class="social"><b>Share:</b> <a href="https://www.facebook.com/sharer/sharer.php?u=https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/" target="_blank" rel="noopener" aria-label="Share on Facebook (opens new tab)"><svg class="icon" aria-hidden="true"><use href="#fab-fa-facebook-f" xlink:href="#fab-fa-facebook-f"></use></svg> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/" target="_blank" rel="noopener" aria-label="Share on LinkedIn (opens new tab)"><svg class="icon" aria-hidden="true"><use href="#fab-fa-linkedin" xlink:href="#fab-fa-linkedin"></use></svg> </a><a href="https://twitter.com/intent/tweet/?text=Prioritizing Reliability When Milliseconds Aren&#39;t Enough&url=https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/" target="_blank" rel="noopener" aria-label="Share on Twitter (opens new tab)"><svg class="icon" aria-hidden="true"><use href="#fab-fa-twitter" xlink:href="#fab-fa-twitter"></use></svg> </a><a href="https://bsky.app/intent/compose?text=https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/" target="_blank" rel="noopener" aria-label="Share on Bluesky (opens new tab)"><svg class="icon" aria-hidden="true"><use href="#fab-fa-bluesky" xlink:href="#fab-fa-bluesky"></use></svg> </a><a aria-label="Copy page link to clipboard" onclick="copyUrlToClipboard()" role="link"><svg class="icon" aria-hidden="true"><use href="#fas-fa-link" xlink:href="#fas-fa-link"></use></svg></a></div></heading-anchors></main><aside><div class="sticky-container"><div class="recents-container aside-content"><span><b>Recent Posts</b></span><div><nav><ol><li><a href="/2025/building-an-enterprise-data-access-layer-automated-auditing/">Building an Enterprise Data Access Layer: Automated Auditing</a></li><li><a href="/2025/building-an-enterprise-data-access-layer-database-and-code-structure/">Building an Enterprise Data Access Layer: Database and Code Structure</a></li><li><a href="/2025/building-an-enterprise-data-access-layer-the-foundation/">Building an Enterprise Data Access Layer: The Foundation</a></li><li><a href="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/">ByteAether.Ulid v1.3.0: Enhanced ULID Generation Control and Security</a></li><li><a href="/2025/prioritizing-reliability-when-milliseconds-arent-enough/">Prioritizing Reliability When Milliseconds Aren&#39;t Enough</a></li></ol></nav></div></div><div class="toc-container"><div class="toc-sticky aside-content"><span><b>Table of Contents</b></span><div><nav class="toc"><ol><li><a href="#the-overflow-scenario%3A-more-likely-than-you-think">The Overflow Scenario: More Likely Than You Think</a><ol><li><a href="#update%3A-the-impact-of-random-increments-on-overflow-probability">Update: The Impact of Random Increments on Overflow Probability</a></li></ol></li><li><a href="#considering-the-alternatives">Considering the Alternatives</a></li><li><a href="#understanding-the-impact%3A-monotonicity-in-practice">Understanding the Impact: Monotonicity in Practice</a></li><li><a href="#why-reliable-monotonicity-matters%3A-the-data-import-example">Why Reliable Monotonicity Matters: The Data Import Example</a></li><li><a href="#a-pragmatic-choice-for-robust-systems">A Pragmatic Choice for Robust Systems</a></li></ol></nav></div></div></div></div></aside></div><div class="bottom-content"><ul class="links-nextprev"><li class="links-nextprev-prev"><a href="/2025/announcing-byteaetherweakevent-v100/"><img src="/2025/announcing-byteaetherweakevent-v100/_9zyMDSnhE-600.webp" alt="" class="banner"><br>Announcing ByteAether.WeakEvent v1.0.0 </a><span>← Previous</span></li><li class="links-nextprev-next"><a href="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/"><img src="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/-swmfyEb5M-600.webp" alt="" class="banner"><br>ByteAether.Ulid v1.3.0: Enhanced ULID Generation Control and Security </a><span>Next →</span></li></ul><div class="series"><h3>Latest posts in the <a href="/series/byteaether-ulid/">ByteAether.Ulid</a> series</h3><div class="series-post"><a href="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/"><img src="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/-swmfyEb5M-400.webp" alt="Illustration image of an article" class="banner"> ByteAether.Ulid v1.3.0: Enhanced ULID Generation Control and Security</a><div>31 July 2025</div></div><div class="series-post"><a href="/2025/prioritizing-reliability-when-milliseconds-arent-enough/"><img src="/2025/prioritizing-reliability-when-milliseconds-arent-enough/8Ivkx3_DqV-400.webp" alt="Illustration image of an article" class="banner"> Prioritizing Reliability When Milliseconds Aren&#39;t Enough</a><div>19 June 2025</div></div><div class="series-post"><a href="/2025/ulids-as-the-default-choice-for-modern-systems-lessons-from-shopifys-payment-infrastructure/"><img src="/2025/ulids-as-the-default-choice-for-modern-systems-lessons-from-shopifys-payment-infrastructure/GU3Aql1_he-400.webp" alt="Illustration image of an article" class="banner"> ULIDs as the Default Choice for Modern Systems: Lessons from Shopify&#39;s Payment Infrastructure</a><div>11 February 2025</div></div></div><div id="giscus-comments"></div><script>document.addEventListener("DOMContentLoaded",()=>{const t=document.getElementById("giscus-comments"),e=document.createElement("script");e.src="https://giscus.app/client.js",e.setAttribute("data-repo","ByteAether/byteaether.github.io"),e.setAttribute("data-repo-id","R_kgDONqpeLw"),e.setAttribute("data-category","Comments"),e.setAttribute("data-category-id","DIC_kwDONqpeL84CmBvx"),e.setAttribute("data-mapping","pathname"),e.setAttribute("data-strict","0"),e.setAttribute("data-reactions-enabled","1"),e.setAttribute("data-emit-metadata","0"),e.setAttribute("data-input-position","top"),e.setAttribute("data-theme",themeManager.get()),e.setAttribute("data-lang","en"),e.setAttribute("data-loading","lazy"),e.setAttribute("crossorigin","anonymous"),e.async=!0,t.appendChild(e)})</script></div><footer><div class="footer-container"><div>ByteAether 2025</div><a href="https://github.com/ByteAether" title="ByteAether" target="_blank"><svg class="icon" aria-hidden="true"><use href="#fab-fa-github" xlink:href="#fab-fa-github"></use></svg></a><a href="/feed/feed.xml" title="Feed" target="_blank"><svg class="icon" aria-hidden="true"><use href="#fas-fa-square-rss" xlink:href="#fas-fa-square-rss"></use></svg></a><span onclick="themeManager.toggle()"><svg class="icon" aria-hidden="true"><use href="#fas-fa-sun" xlink:href="#fas-fa-sun"></use></svg></span></div></footer><svg style="display: none;"><symbol data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github" role="img" viewBox="0 0 512 512" aria-hidden="true" id="fab-fa-github"><path fill="currentColor" d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM252.8 8c-138.7 0-244.8 105.3-244.8 244 0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1 100-33.2 167.8-128.1 167.8-239 0-138.7-112.5-244-251.2-244zM105.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="fas" data-icon="square-rss" class="svg-inline--fa fa-square-rss" role="img" viewBox="0 0 448 512" aria-hidden="true" id="fas-fa-square-rss"><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM96 136c0-13.3 10.7-24 24-24 137 0 248 111 248 248 0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24 83.9 0 152 68.1 152 152 0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104-13.3 0-24-10.7-24-24zm0 120a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun" role="img" viewBox="0 0 576 512" aria-hidden="true" id="fas-fa-sun"><path fill="currentColor" d="M178.2-10.1c7.4-3.1 15.8-2.2 22.5 2.2l87.8 58.2 87.8-58.2c6.7-4.4 15.1-5.2 22.5-2.2S411.4-.5 413 7.3l20.9 103.2 103.2 20.9c7.8 1.6 14.4 7 17.4 14.3s2.2 15.8-2.2 22.5l-58.2 87.8 58.2 87.8c4.4 6.7 5.2 15.1 2.2 22.5s-9.6 12.8-17.4 14.3L433.8 401.4 413 504.7c-1.6 7.8-7 14.4-14.3 17.4s-15.8 2.2-22.5-2.2l-87.8-58.2-87.8 58.2c-6.7 4.4-15.1 5.2-22.5 2.2s-12.8-9.6-14.3-17.4L143 401.4 39.7 380.5c-7.8-1.6-14.4-7-17.4-14.3s-2.2-15.8 2.2-22.5L82.7 256 24.5 168.2c-4.4-6.7-5.2-15.1-2.2-22.5s9.6-12.8 17.4-14.3L143 110.6 163.9 7.3c1.6-7.8 7-14.4 14.3-17.4zM207.6 256a80.4 80.4 0 1 1 160.8 0 80.4 80.4 0 1 1 -160.8 0zm208.8 0a128.4 128.4 0 1 0 -256.8 0 128.4 128.4 0 1 0 256.8 0z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars" role="img" viewBox="0 0 448 512" aria-hidden="true" id="fas-fa-bars"><path fill="currentColor" d="M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="far" data-icon="calendar" class="svg-inline--fa fa-calendar" role="img" viewBox="0 0 448 512" aria-hidden="true" id="far-fa-calendar"><path fill="currentColor" d="M120 0c13.3 0 24 10.7 24 24l0 40 160 0 0-40c0-13.3 10.7-24 24-24s24 10.7 24 24l0 40 32 0c35.3 0 64 28.7 64 64l0 288c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 128C0 92.7 28.7 64 64 64l32 0 0-40c0-13.3 10.7-24 24-24zm0 112l-56 0c-8.8 0-16 7.2-16 16l0 48 352 0 0-48c0-8.8-7.2-16-16-16l-264 0zM48 224l0 192c0 8.8 7.2 16 16 16l320 0c8.8 0 16-7.2 16-16l0-192-352 0z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="far" data-icon="clock" class="svg-inline--fa fa-clock" role="img" viewBox="0 0 512 512" aria-hidden="true" id="far-fa-clock"><path fill="currentColor" d="M464 256a208 208 0 1 1 -416 0 208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0 256 256 0 1 0 -512 0zM232 120l0 136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2 280 120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="fas" data-icon="rectangle-list" class="svg-inline--fa fa-rectangle-list" role="img" viewBox="0 0 512 512" aria-hidden="true" id="fas-fa-rectangle-list"><path fill="currentColor" d="M64 64C28.7 64 0 92.7 0 128L0 384c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-256c0-35.3-28.7-64-64-64L64 64zm96 256a32 32 0 1 1 -64 0 32 32 0 1 1 64 0zm-32-96a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm120-56l144 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-144 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm0 128l144 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-144 0c-13.3 0-24-10.7-24-24s10.7-24 24-24z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="fas" data-icon="tags" class="svg-inline--fa fa-tags" role="img" viewBox="0 0 576 512" aria-hidden="true" id="fas-fa-tags"><path fill="currentColor" d="M401.2 39.1L549.4 189.4c27.7 28.1 27.7 73.1 0 101.2L393 448.9c-9.3 9.4-24.5 9.5-33.9 .2s-9.5-24.5-.2-33.9L515.3 256.8c9.2-9.3 9.2-24.4 0-33.7L367 72.9c-9.3-9.4-9.2-24.6 .2-33.9s24.6-9.2 33.9 .2zM32.1 229.5L32.1 96c0-35.3 28.7-64 64-64l133.5 0c17 0 33.3 6.7 45.3 18.7l144 144c25 25 25 65.5 0 90.5L285.4 418.7c-25 25-65.5 25-90.5 0l-144-144c-12-12-18.7-28.3-18.7-45.3zm144-85.5a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="fab" data-icon="facebook-f" class="svg-inline--fa fa-facebook-f" role="img" viewBox="0 0 320 512" aria-hidden="true" id="fab-fa-facebook-f"><path fill="currentColor" d="M80 299.3l0 212.7 116 0 0-212.7 86.5 0 18-97.8-104.5 0 0-34.6c0-51.7 20.3-71.5 72.7-71.5 16.3 0 29.4 .4 37 1.2l0-88.7C291.4 4 256.4 0 236.2 0 129.3 0 80 50.5 80 159.4l0 42.1-66 0 0 97.8 66 0z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin" role="img" viewBox="0 0 448 512" aria-hidden="true" id="fab-fa-linkedin"><path fill="currentColor" d="M416 32L31.9 32C14.3 32 0 46.5 0 64.3L0 447.7C0 465.5 14.3 480 31.9 480L416 480c17.6 0 32-14.5 32-32.3l0-383.4C448 46.5 433.6 32 416 32zM135.4 416l-66.4 0 0-213.8 66.5 0 0 213.8-.1 0zM102.2 96a38.5 38.5 0 1 1 0 77 38.5 38.5 0 1 1 0-77zM384.3 416l-66.4 0 0-104c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9l0 105.8-66.4 0 0-213.8 63.7 0 0 29.2 .9 0c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9l0 117.2z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="fab" data-icon="twitter" class="svg-inline--fa fa-twitter" role="img" viewBox="0 0 512 512" aria-hidden="true" id="fab-fa-twitter"><path fill="currentColor" d="M459.4 151.7c.3 4.5 .3 9.1 .3 13.6 0 138.7-105.6 298.6-298.6 298.6-59.5 0-114.7-17.2-161.1-47.1 8.4 1 16.6 1.3 25.3 1.3 49.1 0 94.2-16.6 130.3-44.8-46.1-1-84.8-31.2-98.1-72.8 6.5 1 13 1.6 19.8 1.6 9.4 0 18.8-1.3 27.6-3.6-48.1-9.7-84.1-52-84.1-103l0-1.3c14 7.8 30.2 12.7 47.4 13.3-28.3-18.8-46.8-51-46.8-87.4 0-19.5 5.2-37.4 14.3-53 51.7 63.7 129.3 105.3 216.4 109.8-1.6-7.8-2.6-15.9-2.6-24 0-57.8 46.8-104.9 104.9-104.9 30.2 0 57.5 12.7 76.7 33.1 23.7-4.5 46.5-13.3 66.6-25.3-7.8 24.4-24.4 44.8-46.1 57.8 21.1-2.3 41.6-8.1 60.4-16.2-14.3 20.8-32.2 39.3-52.6 54.3z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="fab" data-icon="bluesky" class="svg-inline--fa fa-bluesky" role="img" viewBox="0 0 576 512" aria-hidden="true" id="fab-fa-bluesky"><path fill="currentColor" d="M407.8 294.7c-3.3-.4-6.7-.8-10-1.3 3.4 .4 6.7 .9 10 1.3zM288 227.1C261.9 176.4 190.9 81.9 124.9 35.3 61.6-9.4 37.5-1.7 21.6 5.5 3.3 13.8 0 41.9 0 58.4S9.1 194 15 213.9c19.5 65.7 89.1 87.9 153.2 80.7 3.3-.5 6.6-.9 10-1.4-3.3 .5-6.6 1-10 1.4-93.9 14-177.3 48.2-67.9 169.9 120.3 124.6 164.8-26.7 187.7-103.4 22.9 76.7 49.2 222.5 185.6 103.4 102.4-103.4 28.1-156-65.8-169.9-3.3-.4-6.7-.8-10-1.3 3.4 .4 6.7 .9 10 1.3 64.1 7.1 133.6-15.1 153.2-80.7 5.9-19.9 15-138.9 15-155.5s-3.3-44.7-21.6-52.9c-15.8-7.1-40-14.9-103.2 29.8-66.1 46.6-137.1 141.1-163.2 191.8z"></path></symbol></svg>
<svg style="display: none;"><symbol data-prefix="fas" data-icon="link" class="svg-inline--fa fa-link" role="img" viewBox="0 0 576 512" aria-hidden="true" id="fas-fa-link"><path fill="currentColor" d="M419.5 96c-16.6 0-32.7 4.5-46.8 12.7-15.8-16-34.2-29.4-54.5-39.5 28.2-24 64.1-37.2 101.3-37.2 86.4 0 156.5 70 156.5 156.5 0 41.5-16.5 81.3-45.8 110.6l-71.1 71.1c-29.3 29.3-69.1 45.8-110.6 45.8-86.4 0-156.5-70-156.5-156.5 0-1.5 0-3 .1-4.5 .5-17.7 15.2-31.6 32.9-31.1s31.6 15.2 31.1 32.9c0 .9 0 1.8 0 2.6 0 51.1 41.4 92.5 92.5 92.5 24.5 0 48-9.7 65.4-27.1l71.1-71.1c17.3-17.3 27.1-40.9 27.1-65.4 0-51.1-41.4-92.5-92.5-92.5zM275.2 173.3c-1.9-.8-3.8-1.9-5.5-3.1-12.6-6.5-27-10.2-42.1-10.2-24.5 0-48 9.7-65.4 27.1L91.1 258.2c-17.3 17.3-27.1 40.9-27.1 65.4 0 51.1 41.4 92.5 92.5 92.5 16.5 0 32.6-4.4 46.7-12.6 15.8 16 34.2 29.4 54.6 39.5-28.2 23.9-64 37.2-101.3 37.2-86.4 0-156.5-70-156.5-156.5 0-41.5 16.5-81.3 45.8-110.6l71.1-71.1c29.3-29.3 69.1-45.8 110.6-45.8 86.6 0 156.5 70.6 156.5 156.9 0 1.3 0 2.6 0 3.9-.4 17.7-15.1 31.6-32.8 31.2s-31.6-15.1-31.2-32.8c0-.8 0-1.5 0-2.3 0-33.7-18-63.3-44.8-79.6z"></path></symbol></svg><script defer="" type="module" src="/js/Kz8feJEDoY.js"></script>
		<!-- This page `https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/` was built on 2025-10-24 07:25:06 -->
		</body></html>