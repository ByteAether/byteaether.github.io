<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="color-scheme" content="light dark"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Prioritizing Reliability When Milliseconds Aren&#39;t Enough | ByteAether</title><meta name="description" content="Universally Unique Lexicographically Sortable Identifiers (ULIDs) represent a significant advancement over traditional UUIDs, offering guaranteed uniqueness ..."/><meta name="keywords" content="posts, ULID, UUID, GUID, ID, Performance, c#, csharp, dotnet, .net, byteaether, blog, tech, programming"/><meta name="author" content="Joonatan Uusväli"/><link rel="canonical" href="https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/"/><script type="application/ld+json">{
	"@context": "https://schema.org",
	"@type": "BlogPosting",
	"mainEntityOfPage": {
		"@type": "WebPage",
		"@id": "https://byteaether.github.io/"
	},
	"headline": "Prioritizing Reliability When Milliseconds Aren&#39;t Enough",
	"description": "Universally Unique Lexicographically Sortable Identifiers (ULIDs) represent a significant advancement over traditional UUIDs, offering guaranteed uniqueness ...",
	"image": "https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-1024.jpeg",
	"author": {
		"@type": "Person",
		"name": "Joonatan Uusväli"
	},
	"publisher": {
		"@type": "Organization",
		"name": "ByteAether",
		"logo": {
			"@type": "ImageObject",
			"url": "https://byteaether.github.io/assets/icon.svg"
		}
	},
	"datePublished": "2025-06-19",
	"dateModified": "2025-08-14"
}</script><link rel="icon" href="/favicon.ico" sizes="any"/><link rel="icon" href="/favicon.svg" type="image/svg+xml"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="manifest" href="/manifest.webmanifest"/><meta property="og:url" content="https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/"/><meta property="og:type" content="website"/><meta property="og:title" content="Prioritizing Reliability When Milliseconds Aren&#39;t Enough | ByteAether"/><meta property="og:description" content="Universally Unique Lexicographically Sortable Identifiers (ULIDs) represent a significant advancement over traditional UUIDs, offering guaranteed uniqueness ..."/><meta property="og:image" content="https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-1024.jpeg"/><meta property="og:image:type" content="image/jpeg"/><meta property="og:image:width" content="1024"/><meta property="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Prioritizing Reliability When Milliseconds Aren&#39;t Enough | ByteAether"/><meta name="twitter:description" content="Universally Unique Lexicographically Sortable Identifiers (ULIDs) represent a significant advancement over traditional UUIDs, offering guaranteed uniqueness ..."/><meta name="twitter:image" content="https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-1024.jpeg"/><meta name="robots" content="index, follow"/><link rel="alternate" href="https://byteaether.github.io/feed/feed.xml" type="application/atom+xml" title="ByteAether"/><meta name="format-detection" content="telephone=no"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta http-equiv="cache-control" content="public, max-age=86400, must-revalidate"/><meta name="generator" content="Eleventy v3.1.2"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-LEY00265EM"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-LEY00265EM")</script><link rel="stylesheet" href="/css/dnTXazc6iC.css"/><link rel="stylesheet" href="/css/YO6a_ZKOnb.css"/><script type="text/javascript">const themeManager={init:function(){this.set(this.get())},toggle:function(){this.set("dark"==this.get()?"light":"dark")},set:function(e){document.documentElement.dataset.theme=e,localStorage.theme=e,this.updateGiscusTheme()},get:function(){return document.documentElement.dataset.theme??localStorage.theme??(window.matchMedia&&window.matchMedia("prefers-color-scheme: dark")?"dark":null)??"light"},updateGiscusTheme:function(){const e="dark"===themeManager.get()?"dark":"light",t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}};themeManager.init()</script></head><body><header><div id="header-container"><a href="/" class="header-left"><img src="/assets/icon.svg" alt="Logo" class="logo-img"/> ByteAether</a><nav class="desktop-nav"><ul><li><a href="/">Home</a></li><li><a href="/search/">Search</a></li><li><a href="/series/">Series</a></li><li><a href="/tags/">Tags</a></li><li><a href="/archive/">Archive</a></li><li><a href="/about/">About</a></li></ul></nav><div class="header-right"><a href="https://github.com/ByteAether" title="ByteAether" target="_blank"><svg class="icon" aria-hidden="true"><use href="#fab-fa-github" xlink:href="#fab-fa-github"></use></svg></a><a href="/feed/feed.xml" title="Feed" target="_blank"><svg class="icon" aria-hidden="true"><use href="#fas-fa-square-rss" xlink:href="#fas-fa-square-rss"></use></svg></a><span onclick="themeManager.toggle()"><svg class="icon" aria-hidden="true"><use href="#fas-fa-sun" xlink:href="#fas-fa-sun"></use></svg></span><label for="nav-toggle" class="burger-menu"><svg class="icon" aria-hidden="true"><use href="#fas-fa-bars" xlink:href="#fas-fa-bars"></use></svg></label></div><input type="checkbox" id="nav-toggle" class="nav-toggle"/><nav class="mobile-nav"><ul><li><a href="/">Home</a></li><li><a href="/search/">Search</a></li><li><a href="/series/">Series</a></li><li><a href="/tags/">Tags</a></li><li><a href="/archive/">Archive</a></li><li><a href="/about/">About</a></li></ul></nav></div></header><div class="content-wrapper"><main id="skip" style="grid-area:main"><heading-anchors><a href="#skip" class="visually-hidden">Skip to main content</a><article><picture><source srcset="/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-400.avif" media="(width < 400px)" type="image/avif"/><source srcset="/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-400.webp" media="(width < 400px)" type="image/webp"/><source srcset="/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-600.avif" media="(width < 600px)" type="image/avif"/><source srcset="/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-600.webp" media="(width < 600px)" type="image/webp"/><source srcset="/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-1024.avif" media="(width >= 600px)" type="image/avif"/><source srcset="/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-1024.webp" media="(width >= 600px)" type="image/webp"/><img src="/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-1024.jpeg" alt="Illustration image for an article" class="banner" fetchpriority="high"/></picture><h1 class="post-title" data-pagefind-meta="title, image:/2025/prioritizing-reliability-when-milliseconds-arent-enough/sq3YxhCTjK-300.jpeg" data-pagefind-sort="date:2025-06-19">Prioritizing Reliability When Milliseconds Aren&#39;t Enough</h1><div class="post-meta"><div class="post-metadata"><div><svg class="icon" aria-hidden="true"><use href="#far-fa-calendar" xlink:href="#far-fa-calendar"></use></svg> <time datetime="2025-06-19" data-pagefind-meta="Published" title="Published at 2025-06-19, updated at 2025-08-14">2025-06-19</time> <span style="display:none" data-pagefind-filter="Year">2025</span></div><div data-words="2,261 words"><svg class="icon" aria-hidden="true"><use href="#far-fa-clock" xlink:href="#far-fa-clock"></use></svg> 11 minutes</div><div><svg class="icon" aria-hidden="true"><use href="#fas-fa-rectangle-list" xlink:href="#fas-fa-rectangle-list"></use></svg> <span class="serie" data-pagefind-filter="Series"><a href="/series/byteaether-ulid/">ByteAether.Ulid</a></span></div><div><svg class="icon" aria-hidden="true"><use href="#fas-fa-tags" xlink:href="#fas-fa-tags"></use></svg> <span class="tag" data-pagefind-filter="Tags"><a href="/tags/ulid/">ULID</a></span> <span class="tag" data-pagefind-filter="Tags"><a href="/tags/uuid/">UUID</a></span> <span class="tag" data-pagefind-filter="Tags"><a href="/tags/guid/">GUID</a></span> <span class="tag" data-pagefind-filter="Tags"><a href="/tags/id/">ID</a></span> <span class="tag" data-pagefind-filter="Tags"><a href="/tags/performance/">Performance</a></span></div></div></div><div data-pagefind-body=""><p>Universally Unique Lexicographically Sortable Identifiers (ULIDs) represent a significant advancement over traditional UUIDs, offering guaranteed uniqueness (within practical limits), natural sortability by time, and a concise, URL-friendly format. These features make them highly suitable for diverse applications, including database keys, distributed tracing, and event identifiers. While the intricacies of ID generation might seem like a deep concern primarily for high-throughput systems, understanding the underlying design choices is valuable for all developers leveraging such libraries.</p><p>A standard ULID consists of a 48-bit timestamp (milliseconds since the Unix epoch) and an 80-bit random component. This structure ensures IDs generally sort chronologically. However, the official specification includes a mechanism to handle multiple IDs generated within the <em>exact same millisecond</em>: it increments the 80-bit random part sequentially. This leads to a critical question: What happens if this increment causes the 80-bit random part to exceed its maximum value?</p><p><a href="https://github.com/ulid/spec" target="_blank" rel="noopener noreferrer">The official specification</a> mandates throwing an overflow exception in this situation. While this adheres strictly to the definition, it introduces a potential point of failure, especially in high-performance systems. Crucially, this isn't just a theoretical concern that requires generating 2^80 IDs. For the <em>first</em> ULID generated within a specific millisecond, the 80-bit portion is initialized with a cryptographically random value. If this initial random value happens to be very close to the maximum possible value (all 1's in binary), even the <em>second</em> ID generated within that same millisecond could trigger the increment overflow and, consequently, an exception. This makes the overflow a far more probable scenario than one might initially assume based purely on the size of the 80-bit space.</p><p>In developing <strong><a href="/series/byteaether-ulid/">ByteAether.Ulid</a></strong>, our C# implementation available on <a href="https://github.com/ByteAether/Ulid" target="_blank" rel="noopener noreferrer">GitHub</a> and <a href="https://www.nuget.org/packages/ByteAether.Ulid" target="_blank" rel="noopener noreferrer">NuGet</a>, we recognized the practical implications of this potential exception. We made a deliberate design choice, a documented deviation from the strict specification, to enhance dependability: instead of throwing an exception, <strong>ByteAether.Ulid</strong> allows the increment operation to <em>flow into the 48-bit timestamp part</em> when the 80-bit random part overflows. This post explains the rationale behind this decision.</p><h2 id="the-overflow-scenario%3A-more-likely-than-you-think" tabindex="-1">The Overflow Scenario: More Likely Than You Think</h2><p>Consider systems that demand high throughput: real-time analytics pipelines, busy web servers handling rapid requests, IoT data ingestion points, or batch processing jobs churning through records. In these environments, generating multiple unique identifiers within a single millisecond is commonplace.</p><p>The ULID specification's approach ensures monotonicity <em>within</em> a millisecond by incrementing the random part. For example:</p><ol><li><code>Ulid.New()</code> at <code>T</code> ms: <code>[Timestamp T | Random Value R1]</code></li><li><code>Ulid.New()</code> at <code>T</code> ms again: <code>[Timestamp T | Random Value R1 + 1]</code></li><li><code>Ulid.New()</code> at <code>T</code> ms yet again: <code>[Timestamp T | Random Value R1 + 2]</code> ... and so on.</li></ol><p>The issue arises when <code>Random Value R1 + n</code> reaches the maximum value representable by 80 bits. As noted earlier, if the initial <code>Random Value R1</code> generated by the secure random number generator is already near this maximum, it might only take one or two subsequent calls to <code>Ulid.New()</code> within the same millisecond to hit the ceiling, if the initial random draw was exceptionally unlucky (i.e., very close to the maximum).</p><p>An implementation strictly following the spec would then throw an exception. This creates significant challenges:</p><ol><li><strong>Reduced Reliability:</strong> ID generation, a typically background concern, becomes a potential source of runtime failure, especially under peak load conditions where reliability is most critical.</li><li><strong>Increased Complexity &amp; Performance Impact:</strong> Developers must anticipate and handle these exceptions. <code>try-catch</code> blocks, particularly when an exception is actually thrown, can incur a non-trivial performance cost, especially in very hot code paths like ID generation. This might lead to implementing retry logic or other workarounds that add complexity and can negatively impact the very performance ULIDs are often chosen to support.</li></ol><h3 id="update%3A-the-impact-of-random-increments-on-overflow-probability" tabindex="-1">Update: The Impact of Random Increments on Overflow Probability</h3><p>With the release of <strong><a href="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/">ByteAether.Ulid v1.3.0</a></strong>, our decision to handle random-part overflow by incrementing the timestamp has become even more critical and relevant. The previous monotonic generation behavior, which incremented the random part by a fixed value of 1, made the overflow scenario more likely than one might assume, especially if the initial random value was close to the maximum.</p><p>The new <strong><code>GenerationOptions</code></strong> configuration object introduces several <code>MonotonicRandomXByte</code> options, which enhance security by allowing the increment value to be a random number. This value can range from 1 to 256 for <code>MonotonicRandom1Byte</code>, up to 1 to 4 294 967 296 for <code>MonotonicRandom4Byte</code>. While this adds an important layer of security against enumeration attacks, it also significantly increases the probability of an 80-bit random part overflow occurring within a single millisecond.</p><p>Consider a scenario where <code>MonotonicRandom4Byte</code> is used. A cryptographically secure random provider could generate an initial 80-bit random component close to the maximum value, and the very next ULID generated in that same millisecond could have an increment value of 2^32, causing an immediate overflow.</p><p>Our approach of allowing the increment to flow into the timestamp directly addresses this increased risk. Instead of a predictable, linear march toward a potential exception, the new random increments make the overflow threshold far more volatile. By not throwing an exception and instead seamlessly incrementing the timestamp, our implementation ensures continued, reliable operation under these new, more complex generation scenarios, reinforcing its value for robust and high-throughput systems.</p><h2 id="considering-the-alternatives" tabindex="-1">Considering the Alternatives</h2><p>When faced with the random-part overflow, beyond throwing an exception (as per the spec), several strategies exist:</p><ol><li><p><strong>Delay Generation:</strong> This approach involves pausing the generation thread until the system clock advances to the next millisecond. While ensuring the timestamp strictly reflects the wall-clock time (or a later one), it introduces artificial latency. Halting execution, even briefly, can create significant bottlenecks in high-throughput systems, effectively throttling the application's performance based on clock resolution rather than processing capability. This often defeats the purpose of using efficient ID generation.</p></li><li><p><strong>Force Initial MSB to Zero:</strong> This technique modifies the generation of the <em>initial</em> random value (<code>R1</code> in the example above) within a millisecond. The most significant bit (MSB) of the 80-bit random part is always set to 0. This effectively means the initial random value is always less than 2^79. Consequently, at least 2^79 increments are guaranteed to be possible within that millisecond before the 80-bit value overflows.</p><ul><li><strong>Pros:</strong> Drastically reduces the <em>probability</em> of encountering an overflow, as 2^79 increments within a single millisecond is practically impossible on current hardware. It eliminates the &quot;bad luck&quot; scenario where the first random value is already near the maximum.</li><li><strong>Cons:</strong> It doesn't technically <em>eliminate</em> the overflow problem, it just pushes the threshold extremely high. A decision is <em>still</em> required for what to do if that 2^79 limit is somehow reached (throw, delay, or increment timestamp). It also slightly reduces the initial entropy from 80 bits to 79 bits, though this effect on collision probability is generally negligible. Fundamentally, it mitigates the likelihood but not the existence of the overflow condition itself.</li></ul></li><li><p><strong>Allow Overflow into Timestamp:</strong> This is the strategy implemented in <strong>ByteAether.Ulid</strong>. When the 80-bit random part reaches its limit and needs to increment, the increment operation carries over, increasing the 48-bit timestamp component by one millisecond. The practical effect is that the generated ULID might have a timestamp slightly &quot;ahead&quot; of the precise system clock time at the moment of generation.</p></li></ol><p>Comparing these, the <strong>ByteAether.Ulid</strong> approach directly addresses the <em>consequence</em> of the overflow by providing a non-blocking, non-exception-throwing resolution, regardless of how likely the overflow is. We contend that this provides the optimal blend of performance, reliability, and practical sortability for demanding applications.</p><h2 id="understanding-the-impact%3A-monotonicity-in-practice" tabindex="-1">Understanding the Impact: Monotonicity in Practice</h2><p>A natural question regarding the timestamp overflow approach is its effect on ULID's sortability and monotonicity guarantees. It's essential to analyze this within realistic contexts.</p><p><strong>Single-Process Monotonicity is Strictly Preserved:</strong> This is the cornerstone of the argument. Within a single running process, <strong>ByteAether.Ulid</strong> <em>guarantees</em> that each call to <code>Ulid.New()</code> produces a ULID value strictly greater than the previous one. Whether the increment occurs within the 80-bit random part or spills over into the 48-bit timestamp part, the resulting 128-bit value increases. This ensures that IDs generated sequentially <em>by the same generator instance</em> remain perfectly sortable relative to each other. This is often the most critical monotonicity requirement for use cases like database record ordering within an import batch.</p><p><strong>Cross-Process Monotonicity is Inherently Approximate:</strong> Attempting to achieve strict, guaranteed millisecond-level chronological ordering using ULIDs <em>across different machines or even different processes on the same machine</em> is inherently unreliable, irrespective of how overflow is handled. Factors like clock skew, network latency, and scheduling jitter mean you cannot reliably assert that <code>ULID_A</code> generated on <code>Machine_1</code> at its perceived time <code>T</code> is strictly less than <code>ULID_B</code> generated on <code>Machine_2</code> at its perceived time <code>T + 1ms</code>.</p><p>Given this reality, the fact that <strong>ByteAether.Ulid</strong> might, in high-contention scenarios, advance the timestamp by a millisecond due to overflow does not practically diminish the utility of ULIDs for cross-process chronological estimation. The timestamp remains a highly accurate representation of the generation time. Crucially, this &quot;future-drift&quot; is typically only by a single millisecond; once the timestamp increments, the subsequent ULID generated in this &quot;new&quot; millisecond has the full 2^80 range for its random component, making further immediate overflows into the timestamp exceptionally unlikely. This minimal adjustment is well within the margin of error already introduced by system clocks and network effects, and it prevents generation failure without meaningfully impacting the approximate sortability expected in distributed contexts.</p><p><strong>Alternative - Centralized ID Generation:</strong> One could achieve stronger cross-instance monotonicity by funneling all ID requests through a dedicated, single-instance &quot;ID Generator Service.&quot; This service could maintain strict ordering. However, this introduces significant drawbacks: primarily, <strong>network latency</strong> for every ID request and a <strong>single point of failure/bottleneck</strong>. This contrasts sharply with the benefit of ULIDs: fast, decentralized, in-process generation. For systems prioritizing low-latency generation, the centralized approach is often impractical.</p><p>In summary, <strong>ByteAether.Ulid</strong>'s approach trades theoretical timestamp purity (which is already compromised in distributed systems) for practical reliability and performance, while fully preserving the critical single-process monotonicity guarantee.</p><h2 id="why-reliable-monotonicity-matters%3A-the-data-import-example" tabindex="-1">Why Reliable Monotonicity Matters: The Data Import Example</h2><p>Let's revisit the large-scale data import workflow to illustrate the value of <strong>ByteAether.Ulid</strong>'s reliable single-process monotonicity. A single process reads millions of source records, transforms them, assigns a ULID, and inserts them into a database.</p><pre class="language-csharp"><code class="language-csharp"><span class="token comment">// Simplified Example using ByteAether.Ulid</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataImporter</span>
<span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IDatabaseRepository</span> _repository<span class="token punctuation">;</span>
	<span class="token comment">// ... constructor ...</span>

	<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ImportData</span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>SourceRecord<span class="token punctuation">></span></span> sourceRecords<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token class-name"><span class="token keyword">var</span></span> recordsToInsert <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>TargetRecord<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> sourceRecord <span class="token keyword">in</span> sourceRecords<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token comment">// ByteAether.Ulid handles potential same-ms overflow gracefully</span>
			<span class="token comment">// Potential high-frequency generation here!</span>
			<span class="token class-name">Ulid</span> newId <span class="token operator">=</span> Ulid<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token class-name"><span class="token keyword">var</span></span> targetRecord <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TargetRecord</span> <span class="token punctuation">{</span>
				Id <span class="token operator">=</span> newId<span class="token punctuation">,</span>
				<span class="token comment">/* ... other fields ... */</span>
			<span class="token punctuation">}</span><span class="token punctuation">;</span>
			recordsToInsert<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>targetRecord<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		_repository<span class="token punctuation">.</span><span class="token function">BulkInsert</span><span class="token punctuation">(</span>recordsToInsert<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// ... other methods and record definitions ...</span>
<span class="token punctuation">}</span></code></pre><p><strong>Advantages in this Scenario:</strong></p><ol><li><strong>Dependable High-Speed Operation:</strong> The import can run at full speed. Even if bursts occur where the random part of the ULID would overflow (potentially after just one previous generation in the same millisecond if the initial random value was high), <strong>ByteAether.Ulid</strong> seamlessly increments the timestamp and continues generation without throwing exceptions. This prevents job failures and avoids the need for complex error handling around <code>Ulid.New()</code>.</li><li><strong>Preserved Processing Order:</strong> Because each <code>newId</code> is guaranteed to be greater than the last within this import process, the generated IDs maintain the sequence in which records were handled. If used as a clustered primary key, this aids database insertion performance and allows efficient time-based range queries on the imported batch. The sequence is inherent in the IDs themselves.</li><li><strong>No Artificial Bottlenecks:</strong> Unlike a delay-based approach, <strong>ByteAether.Ulid</strong> doesn't artificially throttle the import speed based on millisecond clock ticks, allowing the system to utilize its full processing power.</li></ol><p>Using an implementation that throws exceptions could lead to sporadic, hard-to-reproduce failures during large imports. Using one that delays would unnecessarily extend the import duration. Using the MSB=0 approach would make failures <em>extremely</em> unlikely, but still theoretically possible, requiring a fallback strategy (like throwing or delaying anyway) that doesn't offer the same definitive resolution. <strong>ByteAether.Ulid</strong> provides a direct, reliable handling mechanism.</p><h2 id="a-pragmatic-choice-for-robust-systems" tabindex="-1">A Pragmatic Choice for Robust Systems</h2><p>The decision in <strong>ByteAether.Ulid</strong> to handle random-part overflow by incrementing the timestamp is a pragmatic one, driven by the need for reliability and performance in real-world applications. It recognizes that the overflow scenario is more likely than a simple 2^80 calculation suggests due to the random starting point within each millisecond.</p><p>This approach:</p><ul><li>Ensures <strong>dependability</strong> by eliminating a source of exceptions in high-throughput scenarios.</li><li>Maintains <strong>performance</strong> by avoiding the latency introduced by delay-based strategies and the overhead of frequent exception handling.</li><li>Guarantees <strong>strict single-process monotonicity</strong>, preserving the most reliable and often most crucial sortability aspect of ULIDs.</li><li>Acknowledges that <strong>cross-process millisecond ordering</strong> is already approximate, making the minor, typically single-millisecond timestamp adjustment during overflow insignificant in that context.</li><li>Provides a <strong>definitive handling mechanism</strong>, unlike approaches that merely reduce the <em>likelihood</em> of overflow without specifying the ultimate fallback.</li></ul><p>While representing a documented deviation from the specification's exception-throwing behavior, this design choice prioritizes building robust, performant systems that can handle demanding workloads without faltering. We believe this makes <strong><a href="https://github.com/ByteAether/Ulid" target="_blank" rel="noopener noreferrer">ByteAether.Ulid</a></strong> a strong choice for developers needing fast, reliable, and sortable unique identifiers in C#.</p></div></article><div class="social"><b>Share:</b> <a href="https://www.facebook.com/sharer/sharer.php?u=https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/" target="_blank" rel="noopener" aria-label="Share on Facebook (opens new tab)"><svg class="icon" aria-hidden="true"><use href="#fab-fa-facebook-f" xlink:href="#fab-fa-facebook-f"></use></svg> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/" target="_blank" rel="noopener" aria-label="Share on LinkedIn (opens new tab)"><svg class="icon" aria-hidden="true"><use href="#fab-fa-linkedin" xlink:href="#fab-fa-linkedin"></use></svg> </a><a href="https://twitter.com/intent/tweet/?text=Prioritizing Reliability When Milliseconds Aren&#39;t Enough&url=https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/" target="_blank" rel="noopener" aria-label="Share on Twitter (opens new tab)"><svg class="icon" aria-hidden="true"><use href="#fab-fa-twitter" xlink:href="#fab-fa-twitter"></use></svg> </a><a href="https://bsky.app/intent/compose?text=https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/" target="_blank" rel="noopener" aria-label="Share on Bluesky (opens new tab)"><svg class="icon" aria-hidden="true"><use href="#fab-fa-bluesky" xlink:href="#fab-fa-bluesky"></use></svg> </a><a aria-label="Copy page link to clipboard" onclick="copyUrlToClipboard()" role="link"><svg class="icon" aria-hidden="true"><use href="#fas-fa-link" xlink:href="#fas-fa-link"></use></svg></a></div></heading-anchors></main><aside style="grid-area:aside"><div class="sticky-container"><div class="recents-container aside-content"><span><b>Recent Posts</b></span><div><nav><ol><li><a href="/2026/the-weight-of-decisions-solving-weighted-random-sorting-at-scale/">The Weight of Decisions: Solving Weighted Random Sorting at Scale</a></li><li><a href="/2025/building-an-enterprise-data-access-layer-automated-user-auditing-and-series-wrap-up/">Building an Enterprise Data Access Layer: Automated User Auditing and Series Wrap-up</a></li><li><a href="/2025/building-an-enterprise-data-access-layer-composable-row-level-security/">Building an Enterprise Data Access Layer: Composable Row-Level Security</a></li><li><a href="/2025/announcing-byteaetherulid-132-net-10-support-and-optimized-design/">Announcing ByteAether.Ulid 1.3.2: .NET 10 Support and Optimized Design</a></li><li><a href="/2025/building-an-enterprise-data-access-layer-composable-multi-tenancy-filtering/">Building an Enterprise Data Access Layer: Composable Multi-Tenancy Filtering</a></li></ol></nav></div></div><div class="toc-container"><div class="toc-sticky aside-content"><span><b>Table of Contents</b></span><div><nav class="toc"><ol><li><a href="#the-overflow-scenario%3A-more-likely-than-you-think">The Overflow Scenario: More Likely Than You Think</a><ol><li><a href="#update%3A-the-impact-of-random-increments-on-overflow-probability">Update: The Impact of Random Increments on Overflow Probability</a></li></ol></li><li><a href="#considering-the-alternatives">Considering the Alternatives</a></li><li><a href="#understanding-the-impact%3A-monotonicity-in-practice">Understanding the Impact: Monotonicity in Practice</a></li><li><a href="#why-reliable-monotonicity-matters%3A-the-data-import-example">Why Reliable Monotonicity Matters: The Data Import Example</a></li><li><a href="#a-pragmatic-choice-for-robust-systems">A Pragmatic Choice for Robust Systems</a></li></ol></nav></div></div></div></div></aside><div class="bottom-content" style="grid-area:bottom"><div class="series"><h2><a href="/series/byteaether-ulid/">ByteAether.Ulid</a> series</h2><a href="/2025/announcing-byteaetherulid-v100-a-high-performance-net-ulid-library-for-modern-applications/" class="box">Announcing ByteAether.Ulid v1.0.0: A High-Performance .NET ULID Library for Modern Applications<span style="color:var(--text-color)"> - 2025-01-21</span> </a><a href="/2025/an-introduction-to-ulids-a-modern-identifier-for-software-systems/" class="box">An Introduction to ULIDs: A Modern Identifier for Software Systems<span style="color:var(--text-color)"> - 2025-01-28</span> </a><a href="/2025/uuid-vs-ulid-vs-integer-ids-a-technical-guide-for-modern-systems/" class="box">UUID vs ULID vs Integer IDs: A Technical Guide for Modern Systems<span style="color:var(--text-color)"> - 2025-02-04</span> </a><a href="/2025/ulids-as-the-default-choice-for-modern-systems-lessons-from-shopifys-payment-infrastructure/" class="box">ULIDs as the Default Choice for Modern Systems: Lessons from Shopify&#39;s Payment Infrastructure<span style="color:var(--text-color)"> - 2025-02-11</span> </a><a href="/2025/prioritizing-reliability-when-milliseconds-arent-enough/" class="box active">Prioritizing Reliability When Milliseconds Aren&#39;t Enough<span style="color:var(--text-color)"> - 2025-06-19</span> </a><a href="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/" class="box">ByteAether.Ulid v1.3.0: Enhanced ULID Generation Control and Security<span style="color:var(--text-color)"> - 2025-07-31</span> </a><a href="/2025/announcing-byteaetherulid-132-net-10-support-and-optimized-design/" class="box">Announcing ByteAether.Ulid 1.3.2: .NET 10 Support and Optimized Design<span style="color:var(--text-color)"> - 2025-11-14</span></a></div><hr/><div class="links-nextprev"><a href="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/" class="box"><picture><source srcset="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/i0q2Ipj7QR-400.avif" media="(width < 600px)" type="image/avif"/><source srcset="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/i0q2Ipj7QR-400.webp" media="(width < 600px)" type="image/webp"/><source srcset="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/i0q2Ipj7QR-600.avif" media="(width >= 600px)" type="image/avif"/><source srcset="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/i0q2Ipj7QR-600.webp" media="(width >= 600px)" type="image/webp"/><img src="/2025/byteaetherulid-v130-enhanced-ulid-generation-control-and-security/i0q2Ipj7QR-600.jpeg" alt="Illustration image for an article" class="banner" loading="lazy"/></picture><div>ByteAether.Ulid v1.3.0: Enhanced ULID Generation Control and Security</div><div style="color:var(--text-color)">← Newer</div></a><a href="/2025/announcing-byteaetherweakevent-v100/" class="box"><picture><source srcset="/2025/announcing-byteaetherweakevent-v100/Of-IoKdc_P-400.avif" media="(width < 400px)" type="image/avif"/><source srcset="/2025/announcing-byteaetherweakevent-v100/Of-IoKdc_P-400.webp" media="(width < 400px)" type="image/webp"/><source srcset="/2025/announcing-byteaetherweakevent-v100/Of-IoKdc_P-600.avif" media="(width >= 400px)" type="image/avif"/><source srcset="/2025/announcing-byteaetherweakevent-v100/Of-IoKdc_P-600.webp" media="(width >= 400px)" type="image/webp"/><img src="/2025/announcing-byteaetherweakevent-v100/Of-IoKdc_P-600.jpeg" alt="Illustration image for an article" class="banner" loading="lazy"/></picture><div>Announcing ByteAether.WeakEvent v1.0.0</div><div style="color:var(--text-color);text-align:right">Older →</div></a></div><div id="giscus-comments"></div><script>document.addEventListener("DOMContentLoaded",()=>{const t=document.getElementById("giscus-comments"),e=document.createElement("script");e.src="https://giscus.app/client.js",e.setAttribute("data-repo","ByteAether/byteaether.github.io"),e.setAttribute("data-repo-id","R_kgDONqpeLw"),e.setAttribute("data-category","Comments"),e.setAttribute("data-category-id","DIC_kwDONqpeL84CmBvx"),e.setAttribute("data-mapping","pathname"),e.setAttribute("data-strict","0"),e.setAttribute("data-reactions-enabled","1"),e.setAttribute("data-emit-metadata","0"),e.setAttribute("data-input-position","top"),e.setAttribute("data-theme",themeManager.get()),e.setAttribute("data-lang","en"),e.setAttribute("data-loading","lazy"),e.setAttribute("crossorigin","anonymous"),e.async=!0,t.appendChild(e)})</script></div></div><footer><div class="footer-container"><div>ByteAether 2025</div><a href="https://github.com/ByteAether" title="ByteAether" target="_blank"><svg class="icon" aria-hidden="true"><use href="#fab-fa-github" xlink:href="#fab-fa-github"></use></svg></a><a href="/feed/feed.xml" title="Feed" target="_blank"><svg class="icon" aria-hidden="true"><use href="#fas-fa-square-rss" xlink:href="#fas-fa-square-rss"></use></svg></a><span onclick="themeManager.toggle()"><svg class="icon" aria-hidden="true"><use href="#fas-fa-sun" xlink:href="#fas-fa-sun"></use></svg></span></div></footer><svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" id="fab-fa-github"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fas" data-icon="square-rss" class="svg-inline--fa fa-square-rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" id="fas-fa-square-rss"><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM96 136c0-13.3 10.7-24 24-24c137 0 248 111 248 248c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200c-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24c83.9 0 152 68.1 152 152c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104c-13.3 0-24-10.7-24-24zm0 120a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="fas-fa-sun"><path fill="currentColor" d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" id="fas-fa-bars"><path fill="currentColor" d="M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="far" data-icon="calendar" class="svg-inline--fa fa-calendar" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" id="far-fa-calendar"><path fill="currentColor" d="M152 24c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 40L64 64C28.7 64 0 92.7 0 128l0 16 0 48L0 448c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-256 0-48 0-16c0-35.3-28.7-64-64-64l-40 0 0-40c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 40L152 64l0-40zM48 192l352 0 0 256c0 8.8-7.2 16-16 16L64 464c-8.8 0-16-7.2-16-16l0-256z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="far" data-icon="clock" class="svg-inline--fa fa-clock" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="far-fa-clock"><path fill="currentColor" d="M464 256A208 208 0 1 1 48 256a208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0A256 256 0 1 0 0 256zM232 120l0 136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2 280 120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rectangle-list" class="svg-inline--fa fa-rectangle-list" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" id="fas-fa-rectangle-list"><path fill="currentColor" d="M0 96C0 60.7 28.7 32 64 32l448 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM128 288a32 32 0 1 0 0-64 32 32 0 1 0 0 64zm32-128a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zM128 384a32 32 0 1 0 0-64 32 32 0 1 0 0 64zm96-248c-13.3 0-24 10.7-24 24s10.7 24 24 24l224 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-224 0zm0 96c-13.3 0-24 10.7-24 24s10.7 24 24 24l224 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-224 0zm0 96c-13.3 0-24 10.7-24 24s10.7 24 24 24l224 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-224 0z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fas" data-icon="tags" class="svg-inline--fa fa-tags" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="fas-fa-tags"><path fill="currentColor" d="M345 39.1L472.8 168.4c52.4 53 52.4 138.2 0 191.2L360.8 472.9c-9.3 9.4-24.5 9.5-33.9 .2s-9.5-24.5-.2-33.9L438.6 325.9c33.9-34.3 33.9-89.4 0-123.7L310.9 72.9c-9.3-9.4-9.2-24.6 .2-33.9s24.6-9.2 33.9 .2zM0 229.5L0 80C0 53.5 21.5 32 48 32l149.5 0c17 0 33.3 6.7 45.3 18.7l168 168c25 25 25 65.5 0 90.5L277.3 442.7c-25 25-65.5 25-90.5 0l-168-168C6.7 262.7 0 246.5 0 229.5zM144 144a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fab" data-icon="facebook-f" class="svg-inline--fa fa-facebook-f" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" id="fab-fa-facebook-f"><path fill="currentColor" d="M80 299.3V512H196V299.3h86.5l18-97.8H196V166.9c0-51.7 20.3-71.5 72.7-71.5c16.3 0 29.4 .4 37 1.2V7.9C291.4 4 256.4 0 236.2 0C129.3 0 80 50.5 80 159.4v42.1H14v97.8H80z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" id="fab-fa-linkedin"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter" class="svg-inline--fa fa-twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="fab-fa-twitter"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fab" data-icon="bluesky" class="svg-inline--fa fa-bluesky" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="fab-fa-bluesky"><path fill="currentColor" d="M111.8 62.2C170.2 105.9 233 194.7 256 242.4c23-47.6 85.8-136.4 144.2-180.2c42.1-31.6 110.3-56 110.3 21.8c0 15.5-8.9 130.5-14.1 149.2C478.2 298 412 314.6 353.1 304.5c102.9 17.5 129.1 75.5 72.5 133.5c-107.4 110.2-154.3-27.6-166.3-62.9l0 0c-1.7-4.9-2.6-7.8-3.3-7.8s-1.6 3-3.3 7.8l0 0c-12 35.3-59 173.1-166.3 62.9c-56.5-58-30.4-116 72.5-133.5C100 314.6 33.8 298 15.7 233.1C10.4 214.4 1.5 99.4 1.5 83.9c0-77.8 68.2-53.4 110.3-21.8z"></path></symbol></svg>
<svg style="display: none;"><symbol aria-hidden="true" focusable="false" data-prefix="fas" data-icon="link" class="svg-inline--fa fa-link" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" id="fas-fa-link"><path fill="currentColor" d="M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z"></path></symbol></svg><script defer="" type="module" src="/js/ovU2bMHLr3.js"></script>
		<!-- This page `https://byteaether.github.io/2025/prioritizing-reliability-when-milliseconds-arent-enough/` was built on 2026-01-08 12:26:40 -->
		</body></html>